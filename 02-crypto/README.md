# LetoCTF Taskbot 2022 | 02-crypto

Автор: [darkside](https://github.com/darkside0000001)

## Информация

> О, нет! Наш флаг зашифровали, но говорят, что шифровальщики допустили ошибку

## Описание

Шифрование алгоритмом RSA

## Статика
- [static.txt](static/static.txt) - статика

## Решение

Рассмотрим константы, которые даны в задании. Судя по ним, это алгоритм RSA. Кратное описание алгоритма
[тут](https://ru.wikipedia.org/wiki/RSA) и [тут](https://www.youtube.com/watch?v=rvxq292a8KY)

Итак, у нас алгоритм RSA и даны 3 числа - модуль, экспонента и зашифрованное сообщение  

Рассмотрим константы 

```
N =  165525547437500830267976213145438893025914428522734190493063899743966337297916639414739200629751985425081934278805337788187406756035733725458466713420230264187543723606843243660400028542876058143951689344456536220961801467440473048322952824306560965460615128518163610684403590064968134460558516948894147455393

e =  65537

c =  71582190157446008956833702904727297532571449781265007160342671392464963186168129138408203949923970778770546411512491571610184057925157609208039000768265629941335966228154492822425912233341325247757306916506041556070029943965552221828801827756656834309869208084692515959114680837793152845991969431273410327777
```

Криптостойкость алгоритма основана на задаче факторизации модуля N. Нужно это для того, чтобы мы могли посчитать значение функции эйлера от N.  

Однако, можем заметить, модуль у нас - простое число. Проверяем это на [сайте](http://factordb.com/). Да, модуль - простое число.  

А функция эйлера от простого числа - [просто вычесть единицу](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0_%D0%BE%D1%82_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE_%D1%87%D0%B8%D1%81%D0%BB%D0%B0).  

Получив значение функции эйлера, мы можем с легкостью посчитать приватный ключ и расшифровать сообщение.
```
phi = N - 1   #считаем функцию эйлера
d = inverse(e,phi)   #считаем приватный ключ 
flag = long_to_bytes(pow(c,d,N)) #расшифровываем сообщение и получаем флаг
```

## Флаг

 Задается аргументом в командной строке
 В примере статики использован флаг `LetoCTF{W3lc0m3_t0_Crypt0}`
